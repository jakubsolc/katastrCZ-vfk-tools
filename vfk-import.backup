

// // g++ my_xpath_select.cpp pugixml.cpp -o z
// // ./z -quiet -addpc 284 -addpc "13/1" -addpc "st. 6/1" -expoo -status > exkuk.m
// // ./z -quiet -ku 618225.xml -addlist "st. 31/1" "st. 32" 526 525 456/8 "st. 28/2" 456/11 528 "st. 65" 456/5 456/9 "st. 33" "st. 34" 11/3 11/4 -expoo > plancach.m


//  VFK importer pro SOBR, ?SPOl, ...

//  potrebuji nacist SOBR, SPOL, SBP, HP, OP

//  hlavni objekty:  tabulka obrazu bodu s pevnym poradim sloupcu


/*  NEUTOPIT SE VE SNAZE O ROBUSTNOST. PROMENNE PORADI V TABULKACH A PROMENNE FORMATY SLOUPCU JSOU AKADEMICKY PROBLEM,
 *  KTERY MOZNA ANI NEEXISTUJE. STACI OTESTOVAT SHODNOST FORMATOVEHO RADKU.
 */

//#include "pugixml.hpp"

#include <iostream>
#include <fstream>
#include <iomanip>  //setw
#include <string>
#include <vector>
#include <map>

#include "safestring.cpp"

#define     DEBPR(A,B)              std::cout << A << B << '\n';

/*
 * 
 * 
 * 
 * 
 * 
 * 
 * 
*/

typedef unsigned long int           TYP_id;
typedef std::vector<TYP_id>         VEC_id;
typedef int                         TYP_idx;
typedef std::vector<TYP_idx>        VEC_idx;
typedef std::vector<std::string>    VEC_s;

class CBoundarySegment
{
public:
    double          X1;
    double          Y1;
    double          X2;
    double          Y2;
    int             CISLO1;
    int             CISLO2;
    int             KODCH1;
    int             KODCH2;
    TYP_id          PAR_ID_1; 
    TYP_id          PAR_ID_2;
    TYP_id          HP_ID;
    std::string     PARAM;
    
    void            pr() const;
    void            swap_order();
    void            prnxy() const;
};

//typedef std::vector<CBoundarySegment> BoundaryList;

class BoundaryList : public std::vector<CBoundarySegment>
{
public:
        void cyclize();
        void mprint(std::string A="A") const;
};
                    
typedef enum {CMD_NOP, CMD_KU, CMD_PC, CMD_PR, CMD_EXP, CMD_EXPOO, CMD_ADDL, CMD_INFO, CMD_ADDPC, CMD_GO, CMD_QUI, CMD_VERB, CMD_DBGA, CMD_HLP, CMD_STAT} VFK_CMD;
typedef enum {VFK_OPCODE_UNKNOWN, VFK_OPCODE_IGNORE, VFK_OPCODE_DSOBR, VFK_OPCODE_BSOBR, VFK_OPCODE_DSBP, VFK_OPCODE_BSBP, VFK_OPCODE_DHP, VFK_OPCODE_BHP, 
                VFK_OPCODE_DOP, VFK_OPCODE_BOP, VFK_OPCODE_DSPOL, VFK_OPCODE_BSPOL} VFK_OPCODE;


class LSOBR          
//              LINE OF TABLE SOBR                 KEY          POV SIZE       (podle specifikace VFK)
{
public:
        long unsigned int   ID;                 // PRIMARY      A   30.0
        int                 STAV_DAT;           //              N   2
        int                 KATUZE_KOD;         // UNIQ CIZI    N   6.0
        int                 CISLO_ZPMZ;         // UNIQ CIZI    N   5
        int                 CISLO_TL;           // UNIQ         N   4
        long int            CISLO_BODU;         // UNIQ         A   12.0
        long int            UPLNE_CISLO;        //              N   12.0
        double              SOURADNICE_Y;       //              A   10.2
        double              SOURADNICE_X;       //              A   10.2
        int                 KOD_CHB;            //      CIZI    N   2.0

        void                pr();               // printer
};

class LSPOL          
//              LINE OF TABLE SOBR                 KEY          POV SIZE       (podle specifikace VFK)
{
public:
        long unsigned int   ID;                 // PRIMARY      A   30.0
        int                 STAV_DAT;           //              N   2
        int                 KATUZE_KOD;         // UNIQ CIZI    N   6.0
        int                 CISLO_ZPMZ;         // UNIQ CIZI    N   5
        int                 CISLO_TL;           // UNIQ         N   4
        long int            CISLO_BODU;         // UNIQ         A   12
        long int            UPLNE_CISLO;        //              A   12
        double              SOURADNICE_Y;       //              A   10.2
        double              SOURADNICE_X;       //              A   10.2
        int                 KOD_CHB;            //      CIZI    N   2.0
        int                 KATUZE_KOD_MER;     // UNIQ CIZI    N   6.0
        int                 CISLO_ZPMZ_MER;     // UNIQ ciZI    N   5

        void                pr();               // printer
};

class LSBP          
//              LINE OF TABLE SOBR                 KEY          POV SIZE       (podle specifikace VFK)
{
public:
        long unsigned int   ID;                     // PRIMARY      A   30.0        !!!
        int                 STAV_DAT;               //              N   2
        std::string         DATUM_VZNIKU;           //              N   D
        std::string         DATUM_ZANIKU;           //              N   D
        int                 PRIZNAK_KONTEXTU;       //              N   1
        std::string         RIZENI_ID_VZNIKU;       //              N   30
        std::string         RIZENI_ID_ZANIKU;       //              N   30
        long unsigned int   BP_ID;                  //      cizi    A   30
        long unsigned int   PORADOVE_CISLO_BODU;    // uniq         A   38
        long unsigned int   OB_ID;                  // uniq CIZI    N   30
        long unsigned int   HP_ID;                  // uniq CIZI    N   30
        long unsigned int   DPM_ID;                 // uniq CIZI    N   30
        std::string         PARAMETRY_SPOJENI;      //              N   T100
        long unsigned int   ZVB_ID;                 //      CIZI    A   30

        void                pr();                   // printer

};

//&BHP;ID N30;STAV_DAT N2;DATUM_VZNIKU D;DATUM_ZANIKU D;PRIZNAK_KONTEXTU N1;RIZENI_ID_VZNIKU N30;RIZENI_ID_ZANIKU N30;TYPPPD_KOD N10;PAR_ID_1 N30;PAR_ID_2 N30

class LHP         
//              LINE OF TABLE SOBR                 KEY          POV SIZE       (podle specifikace VFK)
{
public:
        long unsigned int   ID;                     // PRIMARY      A   30.0        !!!
        int                 STAV_DAT;               //              N   2
        std::string         DATUM_VZNIKU;           //              N   D
        std::string         DATUM_ZANIKU;           //              N   D
        int                 PRIZNAK_KONTEXTU;       //              N   1
        std::string         RIZENI_ID_VZNIKU;       //              N   30
        std::string         RIZENI_ID_ZANIKU;       //              N   30
        int                 TYPPPD_KOD;             //              A   10
        long unsigned int   PAR_ID_1;               //      CIZI    A   30
        long unsigned int   PAR_ID_2;               //              N   30

        void                pr();                   // printer

};

class LOP        
//              LINE OF TABLE SOBR                 KEY          POV SIZE       (podle specifikace VFK)
{
public:
        long unsigned int   ID;                     // PRIMARY      A   30.0        !!!
        int                 STAV_DAT;               //              N   2
        std::string         DATUM_VZNIKU;           //              N   D
        std::string         DATUM_ZANIKU;           //              N   D
        int                 PRIZNAK_KONTEXTU;       //              N   1
        std::string         RIZENI_ID_VZNIKU;       //              N   30
        std::string         RIZENI_ID_ZANIKU;       //              N   30
        int                 TYPPPD_KOD;             //              A   10
        double              SOURADNICE_Y;           //              N   10.2
        double              SOURADNICE_X;           //              N   10.2
        std::string         TEXT;                   //              N   VARCHAR2 255
        double              VELIKOST;               //              N   10.2
        double              UHEL;                   //              N   10.2
        long unsigned int   PAR_ID;                 //      CIZI    A   30
        std::string         OPAR_TYPE;              //              A   VARCHAR2 10
        int                 VZTAZNY_BOD;            //              N   2

        void                pr();                   // printer

};

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

class TSOBR
{
public:
        std::vector<LSOBR>   data;

        void        pr();
        void        status();

        void        import_line(std::string li);
//        static const int wd = 13;
        static const char BSTRING[];

        TYP_idx     find_point_by_id(TYP_id pt);
};

class TSPOL
{
public:
        std::vector<LSPOL>   data;

        void        pr();
        void        status();

        void        import_line(std::string li);
//        static const int wd = 13;
        static const char BSTRING[];
};

class TSBP
{
public:
        std::vector<LSBP>   data;

        void        pr();
        void        status();

        void        import_line(std::string li);
//        static const int wd = 13;
        static const char BSTRING[];
        int         find_sources_of_hplist(VEC_id hp_ids, VEC_idx &sbp_idx, VEC_idx &sbp_12, VEC_id &sbp_XY_id, VEC_idx &whathp_idx);
};

class THP
{
public:
        std::vector<LHP>   data;

        void        pr();
        void        status();

        void        import_line(std::string li);
//        static const int wd = 13;
        static const char BSTRING[];
        int         find_par_id(TYP_id source_id, std::vector<int> &indi, VEC_id &par_ids);
};
class TOP
{
public:
        std::vector<LOP>   data;

        void        pr();
        void        status();

        void        import_line(std::string li);
//        static const int wd = 13;
        static const char BSTRING[];
        
        TYP_idx     find_parcela(std::string s, int st);    //stavebni: st=1, vraci idx
        std::string get_parcela_name(TYP_id pc, int &idx, int &typ);
        int         uniquize_list(VEC_s &par_cis, VEC_idx &par_idx, VEC_idx &typppd);
        void        print_neighbors(const VEC_idx indi_op, const VEC_id par_ids, const VEC_s par_cisla, const VEC_idx par_typppd);
};

class TOB
{
public:
        std::vector<LSBP>   data;

        void        pr();
    //    void        status();

//        void        import_line(std::string li);
//        static const int wd = 13;
      //  static const char BSTRING[];
};

                                      
class TDatabase
{
public:
        TSOBR *p_sobr;
        TSPOL *p_spol;
        TSBP *p_sbp;
        THP *p_hp;
        TOP *p_op;
        
        TDatabase() : p_sobr(NULL),p_spol(NULL),p_sbp(NULL),p_hp(NULL),p_op(NULL) {};
        void info();
        void clear();
        int find_parcela_neighbors(std::string s, int st,  VEC_idx &indi_hp, VEC_idx &indi_op, VEC_id &par_ids, VEC_s &par_cisla, VEC_idx &typppd);
        int parcela_coord(std::string s, int st,  BoundaryList &L);
        void print_parcela_coord(const BoundaryList L) const;
};

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

const char TSBP::BSTRING[] = {"&BSBP;ID N30;STAV_DAT N2;DATUM_VZNIKU D;DATUM_ZANIKU D;PRIZNAK_KONTEXTU N1;RIZENI_ID_VZNIKU N30;RIZENI_ID_ZANIKU N30;BP_ID N30;\
                                      PORADOVE_CISLO_BODU N38;OB_ID N30;HP_ID N30;DPM_ID N30;PARAMETRY_SPOJENI T100;ZVB_ID N30"}; 

const char TSOBR::BSTRING[] = {"&BSOBR;ID N30;STAV_DAT N2;KATUZE_KOD N6;CISLO_ZPMZ N5;CISLO_TL N4;CISLO_BODU N12;UPLNE_CISLO N12;SOURADNICE_Y N10.2;SOURADNICE_X N10.2;KODCHB_KOD N2"};
const char TSPOL::BSTRING[] = {"&BSPOL;ID N30;STAV_DAT N2;KATUZE_KOD N6;CISLO_ZPMZ N5;CISLO_TL N4;CISLO_BODU N12;UPLNE_CISLO N12;SOURADNICE_Y N10.2;SOURADNICE_X N10.2;KODCHB_KOD N2;KATUZE_KOD_MER N6;CISLO_ZPMZ_MER N5"};
    
const char TOP::BSTRING[] = {"&BOP;ID N30;STAV_DAT N2;DATUM_VZNIKU D;DATUM_ZANIKU D;PRIZNAK_KONTEXTU N1;RIZENI_ID_VZNIKU N30;RIZENI_ID_ZANIKU N30;TYPPPD_KOD N10;\
                                SOURADNICE_Y N10.2;SOURADNICE_X N10.2;TEXT T255;VELIKOST N10.2;UHEL N10.4;PAR_ID N30;OPAR_TYPE T10;VZTAZNY_BOD N2"};
const char THP::BSTRING[] = {"&BHP;ID N30;STAV_DAT N2;DATUM_VZNIKU D;DATUM_ZANIKU D;PRIZNAK_KONTEXTU N1;RIZENI_ID_VZNIKU N30;RIZENI_ID_ZANIKU N30;TYPPPD_KOD N10;PAR_ID_1 N30;PAR_ID_2 N30"};


void LSOBR::pr()
{
    const int wdl  = 16;
    const int wds  = 8;
    
        std::cout << std::fixed << std::setprecision(2) << std::right;
        std::cout << std::setw(wdl) <<  ID;
        std::cout << std::setw(wds) <<  STAV_DAT;
        std::cout << std::setw(wds) <<  KATUZE_KOD;
        std::cout << std::setw(wds) <<  CISLO_ZPMZ;
        std::cout << std::setw(wds) <<  CISLO_TL;
        std::cout << std::setw(wdl) <<  CISLO_BODU;
        std::cout << std::setw(wdl) <<  UPLNE_CISLO;
        std::cout << std::setw(wdl) <<  SOURADNICE_Y;
        std::cout << std::setw(wdl) <<  SOURADNICE_X;
        std::cout << std::setw(wds) <<  KOD_CHB;
        std::cout << "\n";
}

void LSPOL::pr()
{
    const int wdl  = 16;
    const int wds  = 8;
    
        std::cout << std::fixed << std::setprecision(2) << std::right;
        std::cout << std::setw(wdl) <<  ID;
        std::cout << std::setw(wds) <<  STAV_DAT;
        std::cout << std::setw(wds) <<  KATUZE_KOD;
        std::cout << std::setw(wds) <<  CISLO_ZPMZ;
        std::cout << std::setw(wds) <<  CISLO_TL;
        std::cout << std::setw(wdl) <<  CISLO_BODU;
        std::cout << std::setw(wdl) <<  UPLNE_CISLO;
        std::cout << std::setw(wdl) <<  SOURADNICE_Y;
        std::cout << std::setw(wdl) <<  SOURADNICE_X;
        std::cout << std::setw(wds) <<  KOD_CHB;
        std::cout << std::setw(wds) <<  KATUZE_KOD_MER;
        std::cout << std::setw(wds) <<  CISLO_ZPMZ_MER;
        std::cout << "\n";
}

void LSBP::pr()
{
    const int wdl  = 16;
    const int wds  = 8;
    
        std::cout << std::fixed << std::setprecision(2) << std::right;
        std::cout << std::setw(wdl) <<  ID;
        std::cout << std::setw(wds) <<  STAV_DAT;
        std::cout << std::setw(wds) <<  DATUM_VZNIKU;
        std::cout << std::setw(wds) <<  DATUM_ZANIKU;
        std::cout << std::setw(wds) <<  PRIZNAK_KONTEXTU;
        std::cout << std::setw(wds) <<  RIZENI_ID_VZNIKU;
        std::cout << std::setw(wds) <<  RIZENI_ID_ZANIKU;
        std::cout << std::setw(wds) <<  BP_ID;
        std::cout << std::setw(wds) <<  PORADOVE_CISLO_BODU;
        std::cout << std::setw(wds) <<  OB_ID;
        std::cout << std::setw(wds) <<  HP_ID;
        std::cout << std::setw(wds) <<  DPM_ID;
        std::cout << std::setw(wds) <<  PARAMETRY_SPOJENI;
        std::cout << std::setw(wds) <<  ZVB_ID;
        std::cout << "\n";
}

void LHP::pr()
{
    const int wdl  = 16;
    const int wds  = 8;
    
        std::cout << std::fixed << std::setprecision(2) << std::right;
        std::cout << std::setw(wdl) <<  ID;
        std::cout << std::setw(wds) <<  STAV_DAT;
        std::cout << std::setw(wds) <<  DATUM_VZNIKU;
        std::cout << std::setw(wds) <<  DATUM_ZANIKU;
        std::cout << std::setw(wds) <<  PRIZNAK_KONTEXTU;
        std::cout << std::setw(wds) <<  RIZENI_ID_VZNIKU;
        std::cout << std::setw(wds) <<  RIZENI_ID_ZANIKU;
        std::cout << std::setw(wds) <<  TYPPPD_KOD;
        std::cout << std::setw(wds) <<  PAR_ID_1;
        std::cout << std::setw(wds) <<  PAR_ID_2;
        std::cout << "\n";
}


void LOP::pr()
{
    const int wdl  = 16;
    const int wds  = 8;
    
        std::cout << std::fixed << std::setprecision(2) << std::right;
        std::cout << std::setw(wdl) <<  ID;
        std::cout << std::setw(wds) <<  STAV_DAT;
        std::cout << std::setw(wds) <<  DATUM_VZNIKU;
        std::cout << std::setw(wds) <<  DATUM_ZANIKU;
        std::cout << std::setw(wds) <<  PRIZNAK_KONTEXTU;
        std::cout << std::setw(wds) <<  RIZENI_ID_VZNIKU;
        std::cout << std::setw(wds) <<  RIZENI_ID_ZANIKU;
        std::cout << std::setw(wds) <<  TYPPPD_KOD;
        std::cout << std::setw(wdl) <<  SOURADNICE_Y;
        std::cout << std::setw(wdl) <<  SOURADNICE_X;
        std::cout << std::setw(wds) <<  TEXT;
        std::cout << std::setw(wds) <<  VELIKOST;
        std::cout << std::setw(wds) <<  UHEL;
        std::cout << std::setw(wds) <<  PAR_ID;
        std::cout << std::setw(wds) <<  OPAR_TYPE;
        std::cout << std::setw(wds) <<  VZTAZNY_BOD;
        std::cout << "\n";
}

// export only one parcel with envelope
void TOB::pr()
{
/*        std::cout << std::setw(wd) << std::left << "\n%  Cislo: " << cislo << "\n";
//        std::cout << << std::setw(8) << std::left <<((strlabel.length()<7) ? "\t" : "\t");
        std::cout << std::setw(wd) << std::left << "PC_IDS{end+1} = '" << cislo << "'\n";
        std::cout << std::setw(wd) << std::left << "PC_RP{end+1}  = [" << refPoint << "];\n";
        std::cout << "PC_COO{end+1} = [ " << coords << "];\n\n";
        std::cout << "PC_RPr{end+1}=reshape(PC_RP{end},2,size(PC_RP{end},2)/2);\n";
        std::cout << "PC_COOr{end+1}=reshape(PC_COO{end},2,size(PC_COO{end},2)/2);\n";
        std::cout << "lw = 3;\n";
        std::cout << "plot(PC_COOr{end}(1,:), PC_COOr{end}(2,:), 'linewidth', lw);\n";
        std::cout << "hold on\n\n";
        std::cout << "text(mean(PC_COOr{end}(1,:)),mean(PC_COOr{end}(2,:)),PC_IDS{end}, 'fontsize', 12, 'horizontalalignment', 'center');\ndaspect([1 1 1]);\n";
//        std::cout << "text(PC_RPr{end}(1,:), PC_RPr{end}(2,:), PC_IDS{end}, 'fontsize', 12, 'horizontalalignment', 'center');\n\n";
*/
}

void CBoundarySegment::swap_order()
{
                std::swap(X1, X2);
                std::swap(Y1, Y2);
                std::swap(KODCH1, KODCH2);
                std::swap(CISLO1, CISLO2);
}

void help(std::map<std::string, VFK_CMD> cmdcode)
{
    for (std::map<std::string, VFK_CMD>::iterator it = cmdcode.begin(); it != cmdcode.end(); it++)
        std::cout << it->first << "\t   " << it->second << "\n";

}


void TDatabase::info()
{
    std::cout << "=========== Data info ==============\n";
    
    std::cout << "SOBR:  ";
    if (p_sobr) {
        std::cout << "ALLOC   " << p_sobr->data.size() << '\n';
    }
    else std::cout << "NULL" << '\n';
    
    std::cout << "SPOL:  ";
    if (p_spol) {
        std::cout << "ALLOC   " << p_spol->data.size() << '\n';
    }
    else std::cout << "NULL" << '\n';

    std::cout << "SBP:   ";
    if (p_sbp) {
        std::cout << "ALLOC   " << p_sbp->data.size() << '\n';
    }
    else std::cout << "NULL" << '\n';
    std::cout << "HP:    ";
    if (p_hp) {
        std::cout << "ALLOC   " << p_hp->data.size() << '\n';
    }
    else std::cout << "NULL" << '\n';
    std::cout << "OP:    ";
    if (p_op) {
        std::cout << "ALLOC   " << p_op->data.size() << '\n';
    }
    else std::cout << "NULL" << '\n';

    std::cout << "===========--------==============\n";
           
}


TYP_idx TSOBR::find_point_by_id(TYP_id pt)
{        
    TYP_idx res = 0;
    while(res < data.size())
    {
        if(data[res].ID == pt) break;
        else res++;
    }
    if (res==data.size()) res = -1;
    return res;   
}

void TSOBR::status()
{
    int nn = data.size();
    std::cout << "=========== status sobr =========\n";
    std::cout << "Size: " << "\t   " << nn << "\n";
    if (nn>20)
    {
        std::cout << "Showing the first 10 records.\n";
        nn = 10;
    }
    for (int k=0; k<nn; k++)
        std::cout << std::setw(12) << data[k].ID << ":\t   " << data[k].CISLO_BODU << "\n";
    for (int k=0; k<nn; k++)
        data[k].pr();
    std::cout << "===========--------==============\n";
           
}

void TSPOL::status()
{
    int nn = data.size();
    std::cout << "=========== status SPOL =========\n";
    std::cout << "Size: " << "\t   " << nn << "\n";
    if (nn>20)
    {
        std::cout << "Showing the first 10 records.\n";
        nn = 10;
    }
    for (int k=0; k<nn; k++)
        std::cout << std::setw(12) << data[k].ID << ":\t   " << data[k].CISLO_BODU << "\n";
    for (int k=0; k<nn; k++)
        data[k].pr();
    std::cout << "===========--------==============\n";
           
}

void TSBP::status()
{
    int nn = data.size();
    std::cout << "=========== status SBP ==========\n";
    std::cout << "Size: " << "\t   " << nn << "\n";
    if (nn>20)
    {
        std::cout << "Showing the first 10 records.\n";
        nn = 10;
    }
    for (int k=0; k<nn; k++)
        std::cout << std::setw(12) << data[k].ID << ":\t   " << data[k].PORADOVE_CISLO_BODU << "   " << data[k].BP_ID << '\n';
    for (int k=0; k<nn; k++)
        data[k].pr();
    std::cout << "===========--------==============\n";
}

void THP::status()
{
    int nn = data.size();
    std::cout << "=========== status HP ===========\n";
    std::cout << "Size: " << "\t   " << nn << "\n";
    if (nn>20)
    {
        std::cout << "Showing the first 10 records.\n";
        nn = 10;
    }
    for (int k=0; k<nn; k++)
        std::cout << std::setw(12) << data[k].ID << ":\t   " << data[k].PAR_ID_1 << "  " << data[k].PAR_ID_2 << "\n";
    for (int k=0; k<nn; k++)
        data[k].pr();
    std::cout << "===========--------==============\n";
}

void TOP::status()
{
    int nn = data.size();
    std::cout << "=========== status OP ===========\n";
    std::cout << "Size: " << "\t   " << nn << "\n";
    if (nn>20)
    {
        std::cout << "Showing the first 10 records.\n";
        nn = 10;
    }
    for (int k=0; k<nn; k++)
        std::cout << std::setw(12) << data[k].ID << ":\t   " << data[k].PAR_ID << "\n";
    for (int k=0; k<nn; k++)
        data[k].pr();
    std::cout << "===========--------==============\n";
}

// najde vsechny hp, ktere ukazuji na danou parcelu
// tj. kazdy segment hranice
// find all, return vec
// returns count of found
int THP::find_par_id(TYP_id source_id, std::vector<int> &indi, VEC_id &par_ids)
{
    indi.clear();
    par_ids.clear();

    for (int k=0; k<data.size(); k++)
    {
        if (data[k].PAR_ID_1 == source_id) 
        {
            indi.push_back(k);
            if (data[k].PAR_ID_2 > 0)
                par_ids.push_back(data[k].PAR_ID_2);        // na statni hranici default value 0    
        }
        if (data[k].PAR_ID_2 == source_id) 
        {
            indi.push_back(k);
            par_ids.push_back(data[k].PAR_ID_1);            // zde povinna polozka, exists
        }
    }
    return indi.size();
}

// stavebni: st=1, pozemkova: st=0,
// vraci idx parcely v OP
// not found == -1
// pozor, v katastru jsou vsechna cisla v uvozovkach, tj. hledat "\"284\""
TYP_idx TOP::find_parcela(std::string s, int st)
{
    int k=0; 
    int kod = st ? 28 : 18;
    while(k<data.size())
    {
        if (data[k].TEXT == s && data[k].TYPPPD_KOD==kod) break; //
//        std::cout << data[k].TEXT << '\n';
        k++;
    }
    
    if (k==data.size()) return -1;
    else return k;
}

//find first
std::string TOP::get_parcela_name(TYP_id pc, int &idx, int &typ)
{
    int k=0; 
    while(k<data.size())
    {
        if (data[k].PAR_ID == pc) break;
        k++;
    }
    
    idx = k;
    if (k==data.size()) return "NULL";
    else 
    {
        typ = data[k].TYPPPD_KOD;
        return data[k].TEXT;
    }
}

int TOP::uniquize_list(VEC_s &par_cis, VEC_idx &par_idx, VEC_idx &typppd)
{

    auto it_cis = par_cis.begin();
    auto it_idx = par_idx.begin();
    auto it_ppd = typppd.begin();
    int k = 0, smaz=0;                      // is not used
    
    while(it_idx != par_idx.end())
    {
        auto it_idx_walk = par_idx.begin();
        while(it_idx_walk != it_idx)
        {
            if( *it_idx_walk == *it_idx ) break;
            it_idx_walk++;
        }

        if (it_idx_walk != it_idx)    // found,  
        {
//            std::cout << "DEB Uniquize: Erase " << *it_cis << "  idx=" << *it_idx << "\n";
            par_cis.erase(it_cis);
            par_idx.erase(it_idx);
            typppd.erase(it_ppd);   // don't increment iterators!
            smaz++;
        }
        else
        {
            it_cis++;
            it_idx++;
            it_ppd++;
            k++;
        }

    }
//    std::cout << "DEB Uniquize: Erase end: uniq=" << k << "  smaz=" << smaz << "  idx_size=" << par_idx.size() << "\n";
    return par_idx.size();

}


//stavebni: st=1
//returns count of found
// pozor, v katastru jsou vsechna cisla v uvozovkach, tj. hledat "\"284\""
int TDatabase::find_parcela_neighbors(std::string s, int st, VEC_idx &indi_hp, VEC_idx &indi_op, VEC_id &par_ids, VEC_s &par_cisla, VEC_idx &typppd)
{
    indi_hp.clear();
    indi_op.clear();
    par_ids.clear();
    par_cisla.clear();
    int pc_idx = p_op->find_parcela(s, st);    
//    std::cout << "DEB Neighbor pc_idx=: " << pc_idx << "\n";
    if (pc_idx == -1) return 0;
    TYP_id pc_id = p_op->data[pc_idx].PAR_ID;
    
//    std::cout << "DEB Neighbor pc_id=: " << pc_id << "\n";

    int res;
    
    res = p_hp -> find_par_id(pc_id, indi_hp, par_ids);

//    std::cout << "DEB Neighbor hp_res=: " << res << "\n";
    
    int neigh_pc_idx;
    int neigh_pc_typ;
    for(int k=0; k<res; k++)
    {
        par_cisla.push_back(p_op -> get_parcela_name(par_ids[k], neigh_pc_idx, neigh_pc_typ));        
        indi_op.push_back(neigh_pc_idx);                
        typppd.push_back(neigh_pc_typ);                
 //       std::cout << "DEB Neighbor parids=: " <<  par_ids[k] << "  op_idx=" << neigh_pc_idx << "  " << par_cisla.back() << "\n";
    }

    
    int kk = indi_op.size();
    while(kk-- > 0)
    {
       if (typppd[kk] != 18 && typppd[kk] != 28)         // nechame jen pozemk a stav parcely
       {
           typppd.erase(typppd.begin()+kk);
           indi_op.erase(indi_op.begin()+kk);
           par_cisla.erase(par_cisla.begin()+kk);
       }
    }

//    std::cout << "DEB Uniquize: orig=" << res << "\n";
    res = p_op -> uniquize_list(par_cisla, indi_op, typppd);
//    std::cout << "DEB Uniquize: orig=" << res << "\n";
    
    return res;
}

void TDatabase::clear()
{
                p_sobr->data.clear();
                p_sbp->data.clear();
                p_spol->data.clear();
                p_hp->data.clear();
                p_op->data.clear();
}


//int TDatabase::find_parcela_neighbors(std::string s, int st, VEC_idx &indi_hp, VEC_idx &indi_op, VEC_id &par_ids, VEC_s &par_cisla, VEC_idx &typppd)



VFK_OPCODE get_opcode(const std::string s)
{
    size_t idx = s.find_first_of(';');  // if not found, whole string is cmd
    
    std::string cm = s.substr(0,idx);
    
    if      (cm == "&DSOBR") return VFK_OPCODE_DSOBR;        // TODO casem predelat na hash (OPCODE,string) nebo obracene
    else if (cm == "&BSOBR") return VFK_OPCODE_BSOBR;
    else if (cm == "&BSBP") return VFK_OPCODE_BSBP;
    else if (cm == "&DSBP") return VFK_OPCODE_DSBP;
    else if (cm == "&BHP") return VFK_OPCODE_BHP;
    else if (cm == "&DHP") return VFK_OPCODE_DHP;
    else if (cm == "&BOP") return VFK_OPCODE_IGNORE;
    else if (cm == "&DOP") return VFK_OPCODE_DOP;
    else if (cm == "&BSPOL") return VFK_OPCODE_IGNORE;
    else if (cm == "&DSPOL") return VFK_OPCODE_DSPOL;
    else if (cm == "&HZMENY") return VFK_OPCODE_IGNORE;
    else if (cm == "&HPOLYG") return VFK_OPCODE_IGNORE;
    else if (cm == "&HKATUZE") return VFK_OPCODE_IGNORE;
    else if (cm == "&DKATUZE") return VFK_OPCODE_IGNORE;
    else if (cm == "&HNAVRHY") return VFK_OPCODE_IGNORE;
    else if (cm == "&HSKUPINA") return VFK_OPCODE_IGNORE;
    else if (cm == "&HPLATNOST") return VFK_OPCODE_IGNORE;
    else if (cm == "&HJMENO") return VFK_OPCODE_IGNORE;
    else if (cm == "&DSPOL") return VFK_OPCODE_IGNORE;
    else if (cm == "&DZVB") return VFK_OPCODE_IGNORE;
    else if (cm == "&BZVB") return VFK_OPCODE_IGNORE;
    else if (cm == "&BDPM") return VFK_OPCODE_IGNORE;
    else if (cm == "&DDPM") return VFK_OPCODE_IGNORE;
    else if (cm == "&DOB") return VFK_OPCODE_IGNORE;
    else if (cm == "&DOBPEJ") return VFK_OPCODE_IGNORE;
    else if (cm == "&DHBPEJ") return VFK_OPCODE_IGNORE;
    else if (cm == "&BOBPEJ") return VFK_OPCODE_IGNORE;
    else if (cm == "&BHBPEJ") return VFK_OPCODE_IGNORE;
    else if (cm == "&DOBBP") return VFK_OPCODE_IGNORE;
    else if (cm == "&BOBBP") return VFK_OPCODE_IGNORE;
    else if (cm == "&DSBP") return VFK_OPCODE_IGNORE;
    else if (cm == "&BSBM") return VFK_OPCODE_IGNORE;
    else if (cm == "&DSBM") return VFK_OPCODE_IGNORE;
    else if (cm == "&BTYPPPD") return VFK_OPCODE_IGNORE;
    else if (cm == "&DTYPPPD") return VFK_OPCODE_IGNORE;
    else if (cm == "&DTYPSOS") return VFK_OPCODE_IGNORE;
    else if (cm == "&BTYPSOS") return VFK_OPCODE_IGNORE;
    else if (cm == "&DKODCHB") return VFK_OPCODE_IGNORE;
    else if (cm == "&BKODCHB") return VFK_OPCODE_IGNORE;
    else if (cm == "&HVERZE") return VFK_OPCODE_IGNORE;
    else if (cm == "&HPUVOD") return VFK_OPCODE_IGNORE;
    else if (cm == "&HVYTVORENO") return VFK_OPCODE_IGNORE;
    else if (cm == "&HCODEPAGE") return VFK_OPCODE_IGNORE;
    else if (cm == "&BOB") return VFK_OPCODE_IGNORE;
    else if (cm == "&BPOM") return VFK_OPCODE_IGNORE;
    else if (cm == "&BSPOM") return VFK_OPCODE_IGNORE;
    else if (cm == "&K") return VFK_OPCODE_IGNORE;

    else return VFK_OPCODE_UNKNOWN;
}


void BoundaryList::cyclize()
{
    for(int k = 1; k < (*this).size(); ++k)           // start from 1, compare with previous
                                                      // the last one k is also important due to swap_order
    {
        int m = k;
        while(m < (*this).size())
        {
                                                    // [k-1].2 connects to m[2]          
            if ((*this)[k-1].CISLO2 == (*this)[m].CISLO2)   
                                                                // muzem porovnat pres cislo bodu,  [ nebo pres SOBR.ID, ale to je zavislost navic, a taky muze byt bod ze SPOL ]          
                                                                // predpokladame tedy existujici a unikatni cisla bodu
                                                                // neunikatnost nezpusobi chybu, ale nedosahne se vysledku - leda porovnat primo XY
            {
                (*this)[m].swap_order();
            }

                                                    // [k-1].2 connects to m[1] 
            if ((*this)[k-1].CISLO2 == (*this)[m].CISLO1)   
            {
                //swap
                if (k != m) std::swap((*this)[k], (*this)[m]);
                break;
            }
            m++;
        }
    }
}



void CBoundarySegment::pr() const
{
    std::cout << std::setw(8) << std::right << CISLO1 << "  " << X1 << "   " << Y1 << "   " << KODCH1 << "   " << std::setw(8) << std::right << CISLO2 << "  " << X2 << "   " << Y2 << "   " << KODCH2 
                << "   " << PAR_ID_1 << "   " << PAR_ID_2 << "   " << HP_ID << "   " << PARAM << "\n";
}

void CBoundarySegment::prnxy() const
{
    std::cout << std::setw(8) << std::right << CISLO1 << "  " << Y1 << "   " << X1 << '\n';
}

void BoundaryList::mprint(std::string A) const
{
    std::cout << A << " = [ %%%%%%%%%%%%%%%%%%%%%%%%%%%\n";
    for (int k = 0; k < (*this).size(); k++)
        (*this)[k].prnxy();
    (*this)[0].prnxy();         //...cycle
    
    std::cout << "]; \n";
    std::cout << "plot(-"<<A<<"(:,2), -"<<A<<"(:,3), 'linewidth', 2); \n";
    std::cout << "daspect([1 1 1]);\nhold on;\nfsz=10;";
    std::cout << "for (k=1:(size("<<A<<",1)-1)), text(-"<<A<<"(k,2), -"<<A<<"(k,3), sprintf('%3d',"<<A<<"(k,1)), 'fontsize',fsz); end\n";
    std::cout << "%%yticks = get (gca, 'ytick');\n"
    "%%ylabels = arrayfun (@(x) sprintf ('%.0f', x), yticks, 'uniformoutput', false);\n"
    "%%set (gca, 'yticklabel', ylabels)\n";

    std::cout << "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";
    
}

// vzhledem k tomu, ze neindexuji primarni klice pro vyhledavani, 
// je potreba vzdy rojit celou tabulku.
// to znamena, ze vyhledani primeho odkazu je stejne efektivni, jako zpetne hledani, lookup je vzdycky
//
// A: lookup OP("6/1"): najdu parid
// B: lookup HP(parid): najdu seznam hranice hplist
// C: lookup SBP(exists in hplist): najdu seznam segmentu Li
// D: lookup SOBR(forall Li)

int TDatabase::parcela_coord(std::string s, int st, BoundaryList &L)
{
    L.clear();
    int res;
    TYP_idx op_idx = p_op->find_parcela(s, st);    
    if (op_idx<0) return 0;
    TYP_id  op_id  = p_op->data[op_idx].PAR_ID;

    VEC_idx indi_hp;
    VEC_id  par_ids;
    res = p_hp -> find_par_id(op_id, indi_hp, par_ids);
    std::cout << "B: res=" << res << "\n";

    VEC_id hp_ids;
    for(auto it = indi_hp.begin(); it != indi_hp.end(); ++it) hp_ids.push_back(p_hp -> data[*it].ID);

    // krok C       lookup SBP(exists in hplist): najdu seznam segmentu Li
    
    VEC_idx  sbp_idx;
    VEC_idx  sbp_12;
    VEC_id   sbp_XY_ids;
    VEC_idx  whathp_idx;
    res = p_sbp -> find_sources_of_hplist(hp_ids, sbp_idx, sbp_12, sbp_XY_ids, whathp_idx);
    
    std::cout << "C: res=" << res << "\n";

    // krok D        lookup SOBR(forall Li)
    VEC_idx body_idx;
    for(int k = 0; k < sbp_idx.size(); ++k) 
    {
        int bod_idx;
        bod_idx = p_sobr -> find_point_by_id(sbp_XY_ids[k]);
            
        if (bod_idx >= 0) body_idx.push_back(bod_idx);
        else return 0;
        
        std::cout << "X " << p_sobr -> data[bod_idx].ID <<  "     " << p_sobr -> data[bod_idx].UPLNE_CISLO << "  " << p_sbp -> data[sbp_idx[k]].PORADOVE_CISLO_BODU << "  " << whathp_idx[k] 
                  << "    " << p_sobr -> data[bod_idx].SOURADNICE_X << "    " << p_sobr -> data[bod_idx].SOURADNICE_Y << "\n";

    }
    
    // krok E - slozeni
    L.resize(hp_ids.size());
    for(int k = 0; k < indi_hp.size(); ++k) 
    {
        L[k].HP_ID  = hp_ids[k];
        L[k].PAR_ID_1  = p_hp -> data[indi_hp[k]].PAR_ID_1;
        L[k].PAR_ID_2  = p_hp -> data[indi_hp[k]].PAR_ID_2;
    }


    for(int k = 0; k < sbp_idx.size(); ++k) 
    {
        if (p_sbp -> data[sbp_idx[k]].PORADOVE_CISLO_BODU == 1)
        {
            L[whathp_idx[k]].X1  = p_sobr -> data[body_idx[k]].SOURADNICE_X;
            L[whathp_idx[k]].Y1  = p_sobr -> data[body_idx[k]].SOURADNICE_Y;
            L[whathp_idx[k]].CISLO1  = p_sobr -> data[body_idx[k]].CISLO_BODU;
            L[whathp_idx[k]].KODCH1  = p_sobr -> data[body_idx[k]].KOD_CHB;
            //TODO kodchar
        }
        else if (p_sbp -> data[sbp_idx[k]].PORADOVE_CISLO_BODU == 2)
        {
            L[whathp_idx[k]].X2  = p_sobr -> data[body_idx[k]].SOURADNICE_X;
            L[whathp_idx[k]].Y2  = p_sobr -> data[body_idx[k]].SOURADNICE_Y;
            L[whathp_idx[k]].CISLO2  = p_sobr -> data[body_idx[k]].CISLO_BODU;
            L[whathp_idx[k]].KODCH2  = p_sobr -> data[body_idx[k]].KOD_CHB;
        } else std::cout << "COORD: Chyba dichotomie.\n";

        
    }
    
    
    L.cyclize();
    
}
    
int TSBP::find_sources_of_hplist(VEC_id hp_ids, VEC_idx &sbp_idx, VEC_idx &sbp_12, VEC_id &sbp_XY_id, VEC_idx &whathp_idx)
{
    int res=0;
    
    for(int k=0; k < data.size(); k++)
    {
        for(int hh=0; hh < hp_ids.size(); hh++)
        {
            if (data[k].HP_ID == hp_ids[hh])
            {
                sbp_idx.push_back(k);           // nekolik(dva) sbp ukazuje na stejne hp, 
                whathp_idx.push_back(hh);
                sbp_12.push_back(data[k].PORADOVE_CISLO_BODU);
                sbp_XY_id.push_back(data[k].BP_ID);      
                res++;
            }
        }
    }
    
    return res;
}

void TDatabase::print_parcela_coord(const BoundaryList L) const
{
        std::cout << "--------------- P A R C    C O O R D   (BOUNDARY)  -------------------------\n";
        for(auto it = L.begin(); it != L.end(); ++it)
        {
            it->pr();
        }
}

std::string get_opcode_str(const std::string s)
{
    size_t idx = s.find_first_of(';');  // if not found, whole string is cmd    
    return s.substr(0,idx);
}

void load_file(std::istream& in, TDatabase &D) {

   std::string tmp;
   VFK_OPCODE opc;
   
   while (!in.eof()) {
      getline(in, tmp, '\n');                    
           
      if (tmp.back() == '\r') tmp.pop_back();       // remove trailing CR
      
      opc = get_opcode(tmp);
      if (opc != VFK_OPCODE_IGNORE)
      {
//          std::cout << "DISPATCH: " << tmp << "   " << "opcode: " << opc << '\n';
      }

      switch(opc)
      {
          case VFK_OPCODE_DSOBR:
              D.p_sobr -> import_line(tmp);
              break;
          case VFK_OPCODE_DSBP:
              D.p_sbp -> import_line(tmp);
              break;
          case VFK_OPCODE_DSPOL:
              D.p_spol -> import_line(tmp);
              break;
          case VFK_OPCODE_DHP:
              D.p_hp -> import_line(tmp);
              break;
          case VFK_OPCODE_DOP:
              D.p_op -> import_line(tmp);
              break;
          case VFK_OPCODE_UNKNOWN:
              std::cout << "Opcode: " << opc << "  " << get_opcode_str(tmp) << " not implemented.\n";
              break;
      }

      tmp.clear();
   }
}


    
// nesmi byt mezera ani za cislem ??? TODO detrail
void TSOBR::import_line(std::string li)
{
//    std::cout << "Importing line |" << li << "|.\n";

   LSOBR newline;
        
   std::vector<std::string> vecstr;

      split_string(li, ';', vecstr);
      
      if (0)    // debug: test splitting
      {
          for (std::vector<std::string>::iterator it = vecstr.begin(); it != vecstr.end(); ++it)
          {
                std::cout << *it << " | ";
          }
          std::cout << "\n";
      }
      
 //     std::cout << vecstr.size();
      // PRO PEVNY FORMAT DSOBR
      if (vecstr.size() != 11)
      {
          std::cout << "Error: format of DSOBR - wrong num of words " << vecstr.size() << "\n";
          return;
      }
          
//      newline.ID            = std::stoul("1234");
//        std::cout << vecstr[1].length() << "  " << vecstr[1] << "\n";
        
        int pos = 1;
        try {
            newline.ID            = safestoul(vecstr[1],0,1);  pos++;      // povinne polozky hodi exception vzdycky
            newline.STAV_DAT      = safestoi(vecstr[2],-1);     pos++;
            newline.KATUZE_KOD    = safestoi(vecstr[3],-1);     pos++;
            newline.CISLO_ZPMZ    = safestoi(vecstr[4],-1);     pos++;
            newline.CISLO_TL      = safestoi(vecstr[5],-1);     pos++;
            newline.CISLO_BODU    = safestol(vecstr[6],0,1);    pos++;
            newline.UPLNE_CISLO   = safestol(vecstr[7],-1);     pos++;
            newline.SOURADNICE_Y  = safestod(vecstr[8],0,1);   pos++;
            newline.SOURADNICE_X  = safestod(vecstr[9],0,1);   pos++;
            newline.KOD_CHB       = safestoi(vecstr[10],-1);
        }
        catch(std::invalid_argument &ia) {
                      std::cout << "Error '" << ia.what() << "': converting '  argno=" << pos << ",  str='" << vecstr[pos] << "'\n";
                      return;
            
        }
        data.push_back(newline);
//      std::cout << "$$$\n";
//      vecstr.clear();
   
}

void TSPOL::import_line(std::string li)
{
//    std::cout << "Importing line |" << li << "|.\n";

   LSPOL newline;
        
   std::vector<std::string> vecstr;

      split_string(li, ';', vecstr);
      
      if (0)    // debug: test splitting
      {
          for (std::vector<std::string>::iterator it = vecstr.begin(); it != vecstr.end(); ++it)
          {
                std::cout << *it << " | ";
          }
          std::cout << "\n";
      }
      
 //     std::cout << vecstr.size();
      // PRO PEVNY FORMAT DSOBR
      if (vecstr.size() != 13)
      {
          std::cout << "Error: format of DSPOL - wrong num of words " << vecstr.size() << "\n";
          return;
      }
          
//      newline.ID            = std::stoul("1234");
//        std::cout << vecstr[1].length() << "  " << vecstr[1] << "\n";
        
        int pos = 1;
        try {
            newline.ID            = safestoul(vecstr[1],0,1);   pos++;      // povinne polozky hodi exception vzdycky
            newline.STAV_DAT      = safestoi(vecstr[2],-1);     pos++;
            newline.KATUZE_KOD    = safestoi(vecstr[3],-1);     pos++;
            newline.CISLO_ZPMZ    = safestoi(vecstr[4],-1);     pos++;
            newline.CISLO_TL      = safestoi(vecstr[5],-1);     pos++;
            newline.CISLO_BODU    = safestol(vecstr[6],0,1);    pos++;
            newline.UPLNE_CISLO   = safestol(vecstr[7],0,1);    pos++;      // povinne
            newline.SOURADNICE_Y  = safestod(vecstr[8],0,1);    pos++;
            newline.SOURADNICE_X  = safestod(vecstr[9],0,1);    pos++;
            newline.KOD_CHB       = safestoi(vecstr[10],-1);    pos++;
            newline.KATUZE_KOD    = safestoi(vecstr[11],-1);    pos++;
            newline.CISLO_ZPMZ    = safestoi(vecstr[12],-1);    
        }
        catch(std::invalid_argument &ia) {
                      std::cout << "Error '" << ia.what() << "': converting '  argno=" << pos << ",  str='" << vecstr[pos] << "'\n";
                      return;
            
        }
        data.push_back(newline);
//      std::cout << "$$$\n";
//      vecstr.clear();
   
}
// nesmi byt mezera ani za cislem ??? TODO detrail
void TSBP::import_line(std::string li)
{
//    std::cout << "Importing line |" << li << "|.\n";

    LSBP newline;
        
   std::vector<std::string> vecstr;

      split_string(li, ';', vecstr);
      
      // PRO PEVNY FORMAT DSOBR
      if (vecstr.size() != 15)        //TODO
      {
          std::cout << "Error: format of DSBP - wrong num of words " << vecstr.size() << "\n";
          return;
      }
          
//      newline.ID            = std::stoul("1234");
//        std::cout << vecstr[1].length() << "  " << vecstr[1] << "\n";

        int pos = 1;
        try {
            newline.ID                      = safestoul(vecstr[1],0,1);     pos++;      // povinne polozky hodi exception vzdycky
            newline.STAV_DAT                = safestoi(vecstr[2],-1);       pos++;
            newline.DATUM_VZNIKU            = vecstr[3];                    pos++;
            newline.DATUM_ZANIKU            = vecstr[4];                    pos++;
            newline.PRIZNAK_KONTEXTU        = safestoi(vecstr[5],-1);       pos++;
            newline.RIZENI_ID_VZNIKU        = vecstr[6];                    pos++;
            newline.RIZENI_ID_ZANIKU        = vecstr[7];                    pos++;
            newline.BP_ID                   = safestoul(vecstr[8],0,1);     pos++;
            newline.PORADOVE_CISLO_BODU     = safestoul(vecstr[9],0,1);     pos++;
            newline.OB_ID                   = safestoul(vecstr[10],0,0);    pos++;
            newline.HP_ID                   = safestoul(vecstr[11],0,0);    pos++;
            newline.DPM_ID                  = safestoul(vecstr[12],0,0);    pos++;
            newline.PARAMETRY_SPOJENI       = vecstr[13];                   pos++;
            newline.ZVB_ID                  = safestoul(vecstr[14],0,0);
        }
        catch(std::invalid_argument &ia) {
                      std::cout << "Error '" << ia.what() << "': converting '  argno=" << pos << ",  str='" << vecstr[pos] << "'\n";
                      return;
            
        }
        data.push_back(newline);
   
}

void THP::import_line(std::string li)
{
//    std::cout << "Importing line |" << li << "|.\n";

    LHP newline;
        
   std::vector<std::string> vecstr;

      split_string(li, ';', vecstr);
      
      // PRO PEVNY FORMAT DSOBR
      if (vecstr.size() != 11)        //TODO
      {
          std::cout << "Error: format of DHP - wrong num of words " << vecstr.size() << "\n";
          return;
      }
          
//      newline.ID            = std::stoul("1234");
//        std::cout << vecstr[1].length() << "  " << vecstr[1] << "\n";

        int pos = 1;
        try {
            newline.ID                      = safestoul(vecstr[1],0,1);     pos++;      // povinne polozky hodi exception vzdycky
            newline.STAV_DAT                = safestoi(vecstr[2],-1);       pos++;
            newline.DATUM_VZNIKU            = vecstr[3];                    pos++;
            newline.DATUM_ZANIKU            = vecstr[4];                    pos++;
            newline.PRIZNAK_KONTEXTU        = safestoi(vecstr[5],-1);       pos++;
            newline.RIZENI_ID_VZNIKU        = vecstr[6];                    pos++;
            newline.RIZENI_ID_ZANIKU        = vecstr[7];                    pos++;
            newline.TYPPPD_KOD              = safestoi(vecstr[8],0,1);      pos++;
            newline.PAR_ID_1                = safestoul(vecstr[9],0,1);     pos++;
            newline.PAR_ID_2                = safestoul(vecstr[10],0,0);    pos++;
        }
        catch(std::invalid_argument &ia) {
                      std::cout << "Error '" << ia.what() << "': converting '  argno=" << pos << ",  str='" << vecstr[pos] << "'\n";
                      return;
            
        }
        data.push_back(newline);
}

void TOP::print_neighbors(const VEC_idx indi_op, const VEC_id par_ids, const VEC_s par_cisla, const VEC_idx par_typppd)
{
             std::cout << "-----------------  Neighbors results:  ----------------\n";

              

              for (int k=0; k<indi_op.size(); k++) data[indi_op[k]].pr();

              int kk = indi_op.size();
              for (int k=0; k<indi_op.size(); k++) 
                  std::cout << k << ":\t " << "  | " << std::setw(6) << indi_op[k] << "\t| " << par_ids[k] << "\t| " << std::setw(8) << std::right << par_cisla[k] << " " << par_typppd[k] << "\n";

              for (int k=0; k < indi_op.size(); k++)
                std::cout << par_cisla[k] << ":" << par_typppd[k] <<"  ";
              std::cout << "\n";

}


std::string quote_string(const char *s)
{
    std::string a = "\"";
    a += s;
    a.push_back('"');
    return a;
}

void TOP::import_line(std::string li)
{
//    std::cout << "Importing line |" << li << "|.\n";

    LOP newline;
        
   std::vector<std::string> vecstr;

      split_string(li, ';', vecstr);
      
      // PRO PEVNY FORMAT DSOBR
      if (vecstr.size() != 17)        //TODO
      {
          std::cout << "Error: format of DOP - wrong num of words " << vecstr.size() << "\n";
          return;
      }
          
//      newline.ID            = std::stoul("1234");
//        std::cout << vecstr[1].length() << "  " << vecstr[1] << "\n";

        int pos = 1;
        try {
            newline.ID                      = safestoul(vecstr[1],0,1);     pos++;      // povinne polozky hodi exception vzdycky
            newline.STAV_DAT                = safestoi(vecstr[2],-1);       pos++;
            newline.DATUM_VZNIKU            = vecstr[3];                    pos++;
            newline.DATUM_ZANIKU            = vecstr[4];                    pos++;
            newline.PRIZNAK_KONTEXTU        = safestoi(vecstr[5],-1);       pos++;
            newline.RIZENI_ID_VZNIKU        = vecstr[6];                    pos++;
            newline.RIZENI_ID_ZANIKU        = vecstr[7];                    pos++;
            newline.TYPPPD_KOD              = safestoi(vecstr[8],0,1);      pos++;
            newline.SOURADNICE_Y            = safestod(vecstr[9],0,0);      pos++;
            newline.SOURADNICE_X            = safestod(vecstr[10],0,0);     pos++;
            newline.TEXT                    = vecstr[11];                   pos++;
            newline.VELIKOST                = safestod(vecstr[12],12,0);    pos++;      //default 12
            newline.UHEL                    = safestod(vecstr[13],0,0);     pos++;
            newline.PAR_ID                  = safestoul(vecstr[14],0,1);    pos++;
            newline.OPAR_TYPE               = vecstr[15];                   pos++;
            newline.VZTAZNY_BOD             = safestoi(vecstr[16],0,0);
        }
        catch(std::invalid_argument &ia) {
                      std::cout << "Error '" << ia.what() << "': converting '  argno=" << pos << ",  str='" << vecstr[pos] << "'\n";
                      return;
            
        }
        data.push_back(newline);
}


int main(int argc, char **argv)
{
        TDatabase DD;
        TSOBR    T;
        TSBP    T_SBP;
        
        TSPOL   T_SPOL;
        THP     T_HP;
        TOP     T_OP;

        DD.p_sobr = &T;
        DD.p_spol = &T_SPOL;
        DD.p_sbp = &T_SBP;
        DD.p_hp = &T_HP;
        DD.p_op = &T_OP;

        if (0)      // first test
    {
        TDatabase DD;
        TSOBR    T;
        DD.p_sobr = &T;
               
        LSOBR    testLSOBR = {12345678901234, 56, 123456, 54321, 4321, 1234567890123, 987654321012, 1234567890.12, 9876543210.12, 34};
        
        T.data.push_back(testLSOBR);
        
        T.status();
        
        testLSOBR.pr();
        
        std::string sampleline = "&DSOBR;5840312209;0;658499;286;;6;2860006;728920.22;1037089.6;8";
        
        T.import_line(sampleline);
    }    
        
        
 
    
    if (1)      // 2. test
    {
        
        LSOBR    testLSOBR = {12345678901234, 56, 123456, 54321, 4321, 1234567890123, 987654321012, 1234567890.12, 9876543210.12, 34};
        
//        T.data.push_back(testLSOBR);
        
 //       T.status();
        
 //       testLSOBR.pr();
        
 //       std::string sampleline = "&DSOBR;5840312209;0;658499;286;;6;2860006;728920.22;1037089.6;8";
 //       T.import_line(sampleline);
        
        std::ifstream in ("724149-mapa.vfk");
        if (!in.good()) 
        { 
            std::cout << "Error opening file. \n";
            
        }
        else
          load_file(in, DD);
        
        //T.status();
        //T_SBP.status();
        DD.info();
        
        do {                // trik pro escape pomoci break
            
          int res = T_OP.find_parcela("\"284\"", 0);
          if (res >= 0) T_OP.data[res].pr();
          else { std::cout << "Parcel 284 not found.\n"; break; }
          
          res = T_OP.find_parcela("\"284\"", 1);
          if (res >= 0) T_OP.data[res].pr();
          else { std::cout << "Parcel 284 not found.\n";}
        
          VEC_idx indi_hp;
          VEC_idx indi_op;
          VEC_idx par_typppd;
          std::vector<long unsigned> par_ids;
          VEC_s par_cisla;
          res = DD.find_parcela_neighbors("\"284\"", 0, indi_hp, indi_op, par_ids, par_cisla, par_typppd);
          if (res >= 0) 
          {
              std::cout << "-----------------  Neighbors:  ----------------\n";
              std::cout << "Neighbor count: " << res <<"\n";
              std::cout << "Neighbor HPindisize: " << indi_hp.size() <<"  OPindisize: " << indi_op.size() << "\n";
              for (int k=0; k < indi_op.size(); k++)
                  std::cout << par_cisla[k] << ":" << par_typppd[k] <<"  ";
              std::cout << "\n";
              
              for (int k=0; k<indi_op.size(); k++) 
                  std::cout << k << ":\t " << indi_hp[k] << "  | " << indi_op[k] << "\t| " << par_ids[k] << "\t| " << std::setw(8) << std::right << par_cisla[k] << " " << par_typppd[k] << "\n";

              for (int k=0; k<indi_op.size(); k++) T_OP.data[indi_op[k]].pr();
    
              std::cout << "-----------------  Results:  ----------------\n";

              int kk = indi_op.size();

              for (int k=0; k<indi_op.size(); k++) 
                  std::cout << k << ":\t " << indi_hp[k] << "  | " << indi_op[k] << "\t| " << par_ids[k] << "\t| " << std::setw(8) << std::right << par_cisla[k] << " " << par_typppd[k] << "\n";
           }
          else 
            {std::cout << "Parcel neighs' 284 not found.\n"; break;}
            
        } while (0);
}
    
/*    if (!global_doc.load_file("724149.xml")) {std::cout << "Error loading default xml file.\n"; return -1;}
 */

        

        DD.clear();
        std::cout << "#########################  M A I N   L O O P  ##################################################" << "\n";

        
        //  DEFAULT FILE
        std::ifstream vfk_instream ("724149-mapa.vfk");

        if (!vfk_instream.good()) 
        { 
            std::cout << "Error opening file. \n";
            
        }
        else
          load_file(vfk_instream, DD);
        DD.info();


    typedef enum {
        // implemented
        CM_NOP, CM_PARC_NEIGHBORS, CM_KU, CM_KUDEFAULT, CM_INFO, CM_CLEAR, CM_PARC_COORD, CM_COORD_MPRINT, CM_CLEAR_CONTEXT,
        // not implemented
        CM_PR, CM_EXP, CM_EXPOO, CM_ADDL,  CM_ADDPC, CM_GO, CM_QUI, CM_VERB, CM_DBGA, CM_HLP, CM_STAT} TCMD;

    std::map<std::string, TCMD> cmdcode = { 
        // implemented
        {"-neighbors",  CM_PARC_NEIGHBORS},  {"-k", CM_KUDEFAULT},  {"-ku", CM_KU},  {"-clear", CM_CLEAR}, {"-info", CM_INFO}, {"-debug_arg", CM_DBGA}, 
        {"-parcel_coord", CM_PARC_COORD}, {"-coord_mprint", CM_COORD_MPRINT}, {"-clear_context", CM_CLEAR_CONTEXT},
        // not implemented
        {"-pr", CM_PR}, {"-exp", CM_EXP}, {"-expoo", CM_EXPOO}, {"-addlist",CM_ADDL},
        {"-addpc", CM_ADDPC}, {"-go", CM_GO}, {"-quiet", CM_QUI}, {"-verb", CM_VERB}, 
        {"-help", CM_HLP}, {"--help", CM_HLP}, {"-status", CM_STAT} };

    std::map<TCMD, int> cmd_argc = { 
        // implemented
        {CM_PARC_NEIGHBORS, 1}, {CM_KU,1}, {CM_KUDEFAULT,0}, {CM_INFO,0}, {CM_CLEAR, 0}, {CM_INFO, 0}, {CM_PARC_COORD, 2}, {CM_COORD_MPRINT, 1}, {CM_CLEAR_CONTEXT,0}
        // not implemented
    };
    
    int tmpint;
    int quiet = 0,
        debug_arg = 0;
    
    int arg_waiting = 0;
    for(int i = 0; i < argc; i++)
    {
        if (cmdcode[argv[i]] == CM_DBGA) debug_arg = 1;
        debug_arg && std::cout << std::left << std::setw(4) << i << ":  " << std::left << std::setw(12) << argv[i] << "  ";
        
        if (arg_waiting == 0) 
        {
            arg_waiting = cmd_argc[cmdcode[argv[i]]];
            debug_arg && std::cout << "OPCODE: " << cmdcode[argv[i]] << (cmdcode[argv[i]] ? "  OK" : "  N/A") << "\n";
        }
        else
        {
            debug_arg && std::cout << "ARG: " << arg_waiting << "\n";
            arg_waiting--;
        }
        if (cmdcode[argv[i]] == CM_QUI) quiet = 1;
    }
    debug_arg && std::cout << "\n";
    
    int i = 1;
    //----------------------  context ----------------------------
    BoundaryList bdList;
    //------------------ end of context --------------------------
    
    while(i < argc)
    {
//todo check argc
        TCMD current_cmd = cmdcode[argv[i]]; 
        auto chkarg  = [&i,&argc](int m) -> bool { if (i+m >= argc) {std::cout << "Arg is missing.\n"; return 0;}; return 1;} ;
        auto chkargc = [&i,&argc,&cmd_argc, &current_cmd]() -> bool { if (i+cmd_argc[current_cmd] >= argc) {std::cout << "CMD " << current_cmd << ": Arg is missing.\n"; return 0;}; return 1;} ;


        VEC_idx tmp_indi_hp;
        VEC_idx tmp_indi_op;
        VEC_idx tmp_par_typppd;
        std::vector<long unsigned> tmp_par_ids;
        VEC_s tmp_par_cisla;
        int res;

        quiet || std::cout << i << ":  " << argv[i] << "  \t";
        quiet || std::cout << "===== PROCESSING OPCODE: " << cmdcode[argv[i]] << (cmdcode[argv[i]] ? "  OK" : "  N/A") << "\n";

        switch(current_cmd)
        {
            case CM_PARC_NEIGHBORS:
                if (!chkargc()) break;
                tmpint = atoi(argv[i+2]);
                res = DD.find_parcela_neighbors(quote_string(argv[i+1]), tmpint, tmp_indi_hp, tmp_indi_op, tmp_par_ids, tmp_par_cisla, tmp_par_typppd);
              std::cout << "-----------------  Neighbors:  ----------------\n";
              std::cout << "Neighbor count: " << res <<"\n";
              std::cout << "Neighbor HPindisize: " << tmp_indi_hp.size() <<"  OPindisize: " << tmp_indi_op.size() << "\n";

                DD.p_op -> print_neighbors(tmp_indi_op, tmp_par_ids, tmp_par_cisla, tmp_par_typppd);
                i += cmd_argc[current_cmd];
                break;
 
            case CM_KUDEFAULT:
                vfk_instream.close();
                vfk_instream.open("724149-mapa.vfk");
                if (!vfk_instream.good()) 
                { 
                    std::cout << "Error opening default file. \n";
                }
                else
                    load_file(vfk_instream, DD);        
                DD.info();
                break;
                
            case CM_KU:
                if (!chkargc()) break;        
                vfk_instream.close();
                vfk_instream.open(argv[i+1]);
                if (!vfk_instream.good()) 
                { 
                    std::cout << "Error opening file '" << argv[i+1] << "'.\n";
                }
                else
                    load_file(vfk_instream, DD);
                DD.info();
                i++;
                break;

            case CM_CLEAR:
                DD.clear();
                DD.info();
                break;

            case CM_CLEAR_CONTEXT:
                bdList.clear();
                break;
                
            case CM_INFO:
                DD.info();
                break;

           case CM_PARC_COORD:
                if (!chkargc()) break;
                tmpint = atoi(argv[i+2]);
                res = DD.parcela_coord(quote_string(argv[i+1]), tmpint, bdList);
                DD.print_parcela_coord(bdList);
                i += cmd_argc[current_cmd];
                break;
 
           case CM_COORD_MPRINT:
                if (!chkargc()) break;
                bdList.mprint(argv[i+1]);
                i += cmd_argc[current_cmd];
                break;
           case CM_PR:
                if (!chkarg(1)) break;
                tmpint = atoi(argv[i+1]);
//                if (tmpint < global_set.parc.size())
//                  global_set.parc[tmpint].pr();
//                else
  //                  std::cout << "Index " << tmpint << " of global_set not found [size=" <<  global_set.parc.size() << "].\n";
                i++;
                break;
            case CM_EXPOO:
 //               global_set.export_set_octave();
                break;
                
            case CM_ADDPC:
                if (!chkarg(1)) break;
   //             global_set.addpc(argv[i+1]);
                i++;
                break;

            case CM_ADDL:
                while ( (i+1 < argc) && argv[i+1][0] != '-')
                {
     //               global_set.addpc(argv[i+1]);
                    i++;
                }
                break;
            case CM_GO:
                if (!chkarg(1)) break;
       //         go(argv[i+1]);
                i++;
                break;
            case CM_QUI:
                quiet = 1;
                break;
            case CM_VERB:
                quiet = 0;
                break;
                
            case CM_HLP:
         //       help(cmdcode);
                break;
            case CM_DBGA:
         //       help(cmdcode);
                break;

            default:
                std::cout << "Unknown command: " << argv[i] << "\n";
                break;
        }
        i++;        
    }
    
    
    
    return 0;
}
